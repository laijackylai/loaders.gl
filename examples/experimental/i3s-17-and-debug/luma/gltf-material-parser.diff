diff --git a/home/user/apps/luma.gl/modules/experimental/src/gltf/gltf-material-parser.js b/./luma/gltf-material-parser.js
index dd3fbc98..d33fedcf 100644
--- a/home/user/apps/luma.gl/modules/experimental/src/gltf/gltf-material-parser.js
+++ b/./luma/gltf-material-parser.js
@@ -1,5 +1,4 @@
 import {Texture2D, hasFeature, FEATURES, log} from '@luma.gl/webgl';
-
 export default class GLTFMaterialParser {
   constructor(
     gl,
@@ -19,8 +18,10 @@ export default class GLTFMaterialParser {
 
     this.uniforms = {
       // TODO: find better values?
+      // eslint-disable-next-line camelcase
       u_Camera: [0, 0, 0], // Model should override
 
+      // eslint-disable-next-line camelcase
       u_MetallicRoughnessValues: [1, 1] // Default is 1 and 1
     };
 
@@ -28,16 +29,22 @@ export default class GLTFMaterialParser {
     this.generatedTextures = [];
 
     if (imageBasedLightingEnvironment) {
+      // eslint-disable-next-line camelcase
       this.uniforms.u_DiffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();
+      // eslint-disable-next-line camelcase
       this.uniforms.u_SpecularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();
+      // eslint-disable-next-line camelcase
       this.uniforms.u_brdfLUT = imageBasedLightingEnvironment.getBrdfTexture();
+      // eslint-disable-next-line camelcase
       this.uniforms.u_ScaleIBLAmbient = [1, 1];
     }
 
     if (pbrDebug) {
       // Override final color for reference app visualization
       // of various parameters in the lighting equation.
+      // eslint-disable-next-line camelcase
       this.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0];
+      // eslint-disable-next-line camelcase
       this.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0];
     }
 
@@ -67,14 +74,30 @@ export default class GLTFMaterialParser {
         gltfTexture.texture.sampler.parameters) ||
       {};
 
+    const image = gltfTexture.texture.source.image;
+    let textureOptions;
+    let specialTextureParameters = {};
+    if (image.compressed) {
+      textureOptions = image;
+      specialTextureParameters = {
+        [this.gl.TEXTURE_MIN_FILTER]:
+          image.data.length > 1 ? this.gl.LINEAR_MIPMAP_NEAREST : this.gl.LINEAR
+      };
+    } else {
+      // Texture2D accepts a promise that returns an image as data (Async Textures)
+      textureOptions = {data: image};
+    }
+
     const texture = new Texture2D(this.gl, {
       id: gltfTexture.name || gltfTexture.id,
-      parameters,
+      parameters: {
+        ...parameters,
+        ...specialTextureParameters
+      },
       pixelStore: {
         [this.gl.UNPACK_FLIP_Y_WEBGL]: false
       },
-      // Texture2D accepts a promise that returns an image as data (Async Textures)
-      data: gltfTexture.texture.source.image
+      ...textureOptions
     });
     this.uniforms[name] = texture;
     this.defineIfPresent(define, define);
@@ -89,6 +112,7 @@ export default class GLTFMaterialParser {
         'HAS_BASECOLORMAP'
       );
     }
+    // eslint-disable-next-line camelcase
     this.uniforms.u_BaseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];
 
     if (pbrMetallicRoughness.metallicRoughnessTexture) {
@@ -99,10 +123,12 @@ export default class GLTFMaterialParser {
       );
     }
     const {metallicFactor = 1, roughnessFactor = 1} = pbrMetallicRoughness;
+    // eslint-disable-next-line camelcase
     this.uniforms.u_MetallicRoughnessValues = [metallicFactor, roughnessFactor];
   }
 
   parseMaterial(material) {
+    // eslint-disable-next-line camelcase
     this.uniforms.pbr_uUnlit = Boolean(material.unlit);
 
     if (material.pbrMetallicRoughness) {
@@ -112,21 +138,25 @@ export default class GLTFMaterialParser {
       this.parseTexture(material.normalTexture, 'u_NormalSampler', 'HAS_NORMALMAP');
 
       const {scale = 1} = material.normalTexture;
+      // eslint-disable-next-line camelcase
       this.uniforms.u_NormalScale = scale;
     }
     if (material.occlusionTexture) {
       this.parseTexture(material.occlusionTexture, 'u_OcclusionSampler', 'HAS_OCCLUSIONMAP');
 
       const {strength = 1} = material.occlusionTexture;
+      // eslint-disable-next-line camelcase
       this.uniforms.u_OcclusionStrength = strength;
     }
     if (material.emissiveTexture) {
       this.parseTexture(material.emissiveTexture, 'u_EmissiveSampler', 'HAS_EMISSIVEMAP');
+      // eslint-disable-next-line camelcase
       this.uniforms.u_EmissiveFactor = material.emissiveFactor || [0, 0, 0];
     }
     if (material.alphaMode === 'MASK') {
       const {alphaCutoff = 0.5} = material;
       this.defines.ALPHA_CUTOFF = 1;
+      // eslint-disable-next-line camelcase
       this.uniforms.u_AlphaCutoff = alphaCutoff;
     } else if (material.alphaMode === 'BLEND') {
       log.warn('BLEND alphaMode might not work well because it requires mesh sorting')();
